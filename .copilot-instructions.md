# Copilot Instructions - ContextSteering-CocosCreator

## Project Overview

This is a **Cocos Creator 3.8 plugin library** for implementing **contextual steering AI behaviors**. The library provides a comprehensive, component-based system for creating intelligent movement and navigation behaviors in 2D and 3D games.

### Key Features
- **Component-based development**: Modular, reusable steering behavior components
- **Flexible configuration**: Easy-to-use configuration system for fine-tuning behaviors
- **12 steering behaviors**: Complete set of fundamental AI steering behaviors
- **Pure TypeScript implementation**: Type-safe, maintainable code
- **High performance**: Optimized for real-time game applications

## Architecture Guidelines

### Component-Based Design
- Each steering behavior should be implemented as a separate Cocos Creator component
- Use composition over inheritance for combining multiple behaviors
- Components should be easily attachable to any Node in the scene
- Follow the Entity-Component-System (ECS) pattern where applicable

### File Structure
```
assets/
├── scripts/
│   ├── steering/
│   │   ├── behaviors/           # Individual steering behavior components
│   │   │   ├── SeekBehavior.ts
│   │   │   ├── FleeBehavior.ts
│   │   │   └── ...
│   │   ├── core/               # Core steering system
│   │   │   ├── SteeringAgent.ts
│   │   │   ├── SteeringForce.ts
│   │   │   └── SteeringConfig.ts
│   │   ├── utils/              # Utility functions and helpers
│   │   └── index.ts            # Main exports
│   └── examples/               # Demo scenes and usage examples
```

## Steering Behaviors to Implement

The library should support these **12 fundamental steering behaviors**:

### Basic Behaviors
1. **Seek** - Move towards a target position
2. **Flee** - Move away from a target position  
3. **Arrive** - Move towards target with deceleration as it approaches
4. **Pursue** - Predict target movement and intercept
5. **Evade** - Predict pursuer movement and escape

### Group Behaviors  
6. **Separation** - Avoid crowding nearby agents
7. **Alignment** - Align movement with nearby agents
8. **Cohesion** - Move towards center of nearby agents
9. **Flock** - Combination of separation, alignment, and cohesion

### Navigation Behaviors
10. **Obstacle Avoidance** - Navigate around static obstacles
11. **Wall Following** - Follow along walls and boundaries
12. **Path Following** - Follow a predefined path or waypoints

## TypeScript Coding Standards

### Code Style
- Use **strict TypeScript** with proper type annotations
- Follow **PascalCase** for classes and components
- Use **camelCase** for methods, properties, and variables
- Use **UPPER_SNAKE_CASE** for constants
- Prefer `const` over `let`, avoid `var`

### Component Structure
```typescript
import { Component, Node, Vec2, Vec3, _decorator } from 'cc';
const { ccclass, property, menu } = _decorator;

@ccclass('SeekBehavior')
@menu('Steering/Seek Behavior')
export class SeekBehavior extends Component {
    @property(Node)
    target: Node = null;
    
    @property({ range: [0, 100] })
    maxForce: number = 10;
    
    @property({ range: [0, 500] })
    maxSpeed: number = 100;
    
    // Implementation...
}
```

### Type Safety
- Always define proper interfaces for configuration objects
- Use generics where appropriate
- Avoid `any` type - use `unknown` if necessary
- Export types and interfaces for external use

## Performance Optimization Guidelines

### Vector Operations
- Reuse Vec2/Vec3 instances to minimize garbage collection
- Use object pooling for frequently created/destroyed objects
- Cache expensive calculations (distance, normalization)
- Use squared distance for comparisons when possible

### Update Loops
- Implement efficient update patterns using Cocos Creator's scheduler
- Use spatial partitioning for neighbor queries when dealing with many agents
- Consider using FixedUpdate for physics-based calculations
- Implement LOD (Level of Detail) for distant agents

### Memory Management
```typescript
// Good: Reuse vector instances
private _tempVec: Vec3 = new Vec3();
private calculateSteering(): Vec3 {
    return Vec3.subtract(this._tempVec, this.target, this.node.position);
}

// Bad: Creates new vectors each frame
private calculateSteering(): Vec3 {
    return new Vec3().set(this.target).subtract(this.node.position);
}
```

## Configuration System

### Behavior Configuration
- Use data-driven approach with serializable configuration objects
- Support runtime configuration changes
- Provide sensible default values
- Include validation for configuration parameters

```typescript
interface SteeringConfig {
    maxSpeed: number;
    maxForce: number;
    arrivalRadius: number;
    slowDownRadius: number;
    separationRadius: number;
    alignmentRadius: number;
    cohesionRadius: number;
}
```

### Weight-Based Combination
- Implement weighted combination system for multiple behaviors
- Allow dynamic weight adjustment at runtime
- Provide presets for common behavior combinations

## Cocos Creator 3.8 Specific Considerations

### Component Lifecycle
- Use `onLoad()` for initialization
- Use `start()` for post-initialization setup
- Use `update(dt)` for frame-based calculations
- Use `lateUpdate(dt)` for post-movement adjustments

### Scene Integration
- Integrate with Cocos Creator's RigidBody2D/3D components
- Support both 2D and 3D coordinate systems
- Work with Cocos Creator's collision detection system
- Support gizmo drawing in the editor for visualization

### Editor Features
- Implement custom property inspectors where beneficial
- Add gizmo visualization for debugging steering forces
- Include scene view helpers for target selection
- Provide editor-time preview of behavior effects

## Testing and Examples

### Unit Testing
- Test individual behavior calculations
- Verify configuration validation
- Test edge cases (zero vectors, null targets, etc.)

### Example Scenes
- Create demo scenes showcasing each behavior
- Include combined behavior examples
- Provide performance testing scenarios
- Document usage patterns and best practices

## API Design Principles

### Ease of Use
- Minimize required configuration for basic usage
- Provide intelligent defaults
- Use descriptive method and property names
- Include comprehensive JSDoc documentation

### Extensibility  
- Allow custom steering behaviors through inheritance
- Provide hooks for custom force calculations
- Support plugin-style extensions
- Maintain backward compatibility

### Integration
- Work seamlessly with existing Cocos Creator projects
- Minimal dependencies on external libraries
- Compatible with both 2D and 3D projects
- Support for different input systems (touch, keyboard, gamepad)

## Documentation Requirements

### Code Documentation
- Comprehensive JSDoc comments for all public APIs
- Include usage examples in comments
- Document parameter ranges and units
- Explain complex algorithms and formulas

### User Documentation  
- README with quick start guide
- API reference documentation
- Tutorial for common use cases
- Performance optimization guide

## Best Practices Summary

1. **Keep components lightweight** - Each behavior should do one thing well
2. **Use composition** - Combine simple behaviors to create complex ones  
3. **Optimize for performance** - Games require real-time performance
4. **Provide good defaults** - Should work out of the box with minimal setup
5. **Make it debuggable** - Include visualization and debugging tools
6. **Follow Cocos Creator patterns** - Integrate naturally with the engine
7. **Type everything** - Use TypeScript's type system fully
8. **Plan for extensibility** - Others should be able to build on this library

When implementing new features or fixing bugs, always consider these principles and maintain consistency with the established patterns.